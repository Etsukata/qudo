=encoding utf8

=head1 NAME 

Qudo::Manual::JA - Qudo's document lang:ja

=head1 DESCRIPTION

QudoはバックエンドにRDBMSなどを利用したJob Queueing Management Systemです。

PerlにはTheSchwartzというJob Queueing Management Systemがありますが、
利用者が拡張しやすくなるように考えてつくりました。

=head1 Job Queueingとは

「Job Queueingとは何か」を簡単に言えば

HTTPサーバで扱うには少し重く厳密なリアルタイム性が求められない処理を

HTTPのサイクルから切り離した部分で処理を行わせる為の仕組みです。


例えば、あるユーザ登録型サイトがあるとして、

ユーザがサイトに登録した場合、登録完了メールをユーザに送る事が有ると思いますが、

実際の登録処理はHTTPのリクエスト内で行いますが、

メールの配信はそこまで厳密なリアルタイム性が求められていないため、

HTTPのサイクル内では実際のメール送信を行わず、

「この人にサイト登録完了メールを送信しておいてね」

という仕事をお願い（Job Queueing）しておき、

メール送信を専門に担当する処理にまかせたりします。

Qudoではこの

「この人にサイト登録完了メールを送信しておいてね」

をお願いするクライアントと

「この人にサイト登録完了メールを送信しておいてね」

を実際に処理するワーカーの仕組みを提供します。

=head1 まず始めに

Qudoを使うにはMySQLもしくはSQLiteにQudo用のデータベースを設定する必要があります。

MySQL用のスキーマはdoc/schema-mysql.sqlに
SQLite用のスキーマはdoc/schema-sqlite.sqlにありますのでこれを基にデータベースを作成してください。


=head1 client

QudoでJob Queueingを行うクライアントは以下のように書きます

    # in your script:
    use Qudo;
    my $client = Qudo->new(
        driver_class => 'Skinny', # DBIx::Skinny
        database => +{
            dsn      => 'dbi:SQLite:/tmp/qudo.db',
            username => '',
            password => '',
        },
    );

    # enqueue job
    $client->enqueue("Your::Worker::Mail", $user->email, $user->login_id);

まずQudoのオブジェクトを作成します。

JobをQueueingするデータベースを指定してオブジェクトを作成します。

作成したオブジェクトを元にJobをQueueingします。

enqueueメソッドの

第一引数はJobを処理させるWorkerの名前

第二引数はWorkerが使う引数の情報

第三引数はJob毎にユニークとなる値を設定します

この例の場合、Jobを処理するクラスとしてYour::Worker::Mailを指定し、

処理させる引数として$user->email（メールアドレス）を指定し、

Jobのユニークキーとして$user->login_id（ログインID）を指定しています。

クライアントが行う処理はこれだけです。

あとはこれから作成するYour::Worker::Mailが勝手に処理してくれます。

=head1 worker

queueingされたJobを処理していくワーカーを作成します

    package Your::Worker::Mail;
    use base 'Qudo::Worker';
    sub work {
        my ($class, $job) = @_;
        print $job->arg; #print $user->email;
        
        # send mail process...
        
        $job->completed; # finished job!
    }
    1;

Qudo::Wokerを継承したクラスを作成し、

workメソッドをオーバーライドしてください。

workメソッドの第二引数にはJobの情報が丸々わたってきます。

$job->argメソッドでQueueingする際に指定した、Workerに使ってほしいと指定された引数情報が格納されています。 

次に、
workerを起動するスクリプトを以下のように用意します

    # ex) qudo-worker.pl :
    use Qudo;
    my $worker = Qudo->new(
        driver_class => 'Skinny',
        database => +{
            dsn      => 'dbi:SQLite:/tmp/qudo.db',
            username => '',
            password => '',
        },
        manager_abilities => [qw/Your::Worker::Mail/], # set worker
    );
    $worker->work(); # boot manager
    # work work work!

clientと同じようにワーカーが使うデータベースを指定してQudoのオブジェクトを作成します。

この時にmanager_abilitiesの引数をつかって、

このworkerが管理するWorkerクラスを指定します。

$worker->work()メソッドよ呼び出すことで、

JobがQueueingされる毎にWorkerクラスを呼び出して処理させています。

基本的にはこれだけです。

簡単でしょ:)

=head1 Hook

Qudoでは各所にHookポイントがあるので、Hookポイントをつかって各種処理を行う事ができます。

Job を enqueueする時に引数をシリアライズしたりなどです。

たとえば、enqueueする引数の情報をJSONでシリアライズしたい場合は

    my $client = Qudo->new(...);
    $client->register_plugins('Qudo::Hook::Serialize::JSON');
    $client->enqueue('Test::Worker', {name => 'nekokak'}, 'uniq');

このようにHookモジュールをregister_pluginsに渡す事で設定でき、
設定した引数がJSONでシリアライズされて保存されます。

Hookは利用者が好きに書く事ができるので、Qudoが持っていない機能も簡単に書く事ができます。






